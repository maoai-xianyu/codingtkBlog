---
title: 一：复杂度分析（2）-浅析最好、最坏、平均、均摊时间复杂度
date: 2019-02-14 17:20:36
tags:
    - 数据结构
    - 算法
categories: "数据结构"
---


## 四个复杂度

* 最坏情况时间复杂度 代码在最理想情况下执行的时间复杂度。
* 最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。
* 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
* 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
int i = 0;
int pos = -1;
for (; i < n; ++i) {
if (array[i] == x) {
pos = i;
break;
}
}
return pos;
}
时间复杂度，用之前的就分析不了了，需要不同时间复杂度。最好，最坏，平均情况时间复杂度
```

### 平均情况时间复杂度

上述案例 
1. 方法一 去平均值
有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中
![image](http://note.youdao.com/yws/public/resource/39d00ecabfab65c552a92425eb15176e/722F4D682D234ACE97659796002E8EDB?ynotemdtimestamp=1550136148697)
O(n)
2. 方法二
在是1/2 不在是 1/2 任意位置是 1/2n 的概率
![image](http://note.youdao.com/yws/public/resource/39d00ecabfab65c552a92425eb15176e/5ABF6D48B8B74AEEA0DF3578838F2EB6?ynotemdtimestamp=1550136148697)
O(n)
加权平均值，也叫做期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

### 均摊时间复杂度

均摊时间复杂度，以及它对应的分析方法，摊还分析（或者叫平摊分析）。

当然，这个例子只是我为了方便讲解想出来的，实际上没人会这么写...

```
// array 表示一个长度为 n 的数组
// 代码中的 array.length 就等于 n
int[] array = new int[n];
int count = 0;

void insert(int val) {
if (count == array.length) {
int sum = 0;
for (int i = 0; i < array.length; ++i) {
sum = sum + array[i];
}
array[0] = sum;
count = 1;
}

array[count] = val;
++count;
}

```
解释： 我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

```
最好情况时间复杂度为: O(1)

最坏情况时间复杂度为: O(n) 
解释方法：
最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入

平均时间复杂度为: O(1)
解释方法：
假设数组的长度是n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均

```
时间复杂度就是：

![image](http://note.youdao.com/yws/public/resource/39d00ecabfab65c552a92425eb15176e/FFC87A517531405CB5DFA098B751B2A9?ynotemdtimestamp=1550136148697)

解释：比较insert()和find()

1. 首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()
2. 不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。


所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。


针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度.


-> 那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？

我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。


均摊时间复杂度就是一种特殊的平均时间复杂度

### 总结

* 为什么要引入这4个概念？

1. 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
2. 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。

* 如何分析平均、均摊时间复杂度？

1. 平均时间复杂度
代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
2. 均摊时间复杂度
两个条件满足时使用：
1. 代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；
2. 低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。



本文是从 王争 数据结构与算法的学习-[04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](https://time.geekbang.org/column/article/40447)。跟着大神学习，逐渐进步
